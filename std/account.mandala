import core.Id
import SubjectManager._
import SubjectLock._
import Lock
import Issuer
import core.sys.Sys._
import core.sys.Ids._
import core.Equal._
import Option._

module Account {
    //Just a Marker Wrapper to aquire Type Ownership for Entry
    //Todo: This could even be standard but linear represents the meaning better
    local linear data Account(owner:Subject)

    type AccountEntry = Entry[Account]
    global temporary linear data AuthInfo(accEntry:AccountEntry, token:AuthenticationToken)

    global transactional function createAccount(owner:Subject, implicit consume gen:IdGenerator):(acc:AccountEntry, newGen:IdGenerator){
        let (id, newGen) = uniqueID(gen) in (Entry#(id, Account#(owner)), newGen)
    }

    global function getOwner(accEntry:AccountEntry):Subject {
        inspect accEntry with Entry(_,acc) => acc.owner
    }

    //This would be nice but would require a transformator that can replace field opcode chains with inspect ones
    //global function getOwner(accEntry:AccountEntry):Subject = accEntry.val.owner

    global transactional function changeOwner(consume accEntry:AccountEntry, newOwner:Subject, auth:AuthenticationToken):AccountEntry {
          let (id,acc)@accEntry in
          match acc.owner == auth.subject with
            | False => rollback()
            | True => Entry#(id, Account#(newOwner))
    }

    global function subjectFor(accEntry:AccountEntry):(subject:ValidatedSubject) {
        validateSubject(authenticatedMessage(SubjectRequest#(privateToPublic(accEntry.id))))
    }

    global overloaded transactional function authenticateWith(accEntry:AccountEntry, token:AuthenticationToken):AuthenticationToken {
        inspect accEntry with Entry(id,acc) =>
        match acc.owner == token.subject with
         | False => rollback()
         | True => authenticate(authenticatedMessage(AuthenticationRequest#(privateToPublic(id))))
    }

    global overloaded transactional function authenticateWith(authInfo:AuthInfo):AuthenticationToken {
        inspect authInfo with AuthInfo(accEntry, token) => authenticateWith(accEntry, token)
    }

    global overloaded function safeAuthenticateWith(accEntry:AccountEntry, token:AuthenticationToken):Option[AuthenticationToken] {
         try authenticateWith(accEntry, token) with
          | success(resToken) => Option#Some(resToken)
          | failure => Option#None
    }

    global overloaded function safeAuthenticateWith(authInfo:AuthInfo):Option[AuthenticationToken] {
        inspect authInfo with AuthInfo(accEntry, token) => safeAuthenticateWith(accEntry, token)
    }

    instance AccountIsIssuer for Issuer[AccountEntry,AuthInfo] {
        implement subjectFor with subjectFor
        implement authenticateWith with authenticateWith
    }

    global function lockWith[T](accEntry:AccountEntry, consume val:T):Locked[T]{
        lock(subjectFor(accEntry).subject,val)
    }

    global transactional function unLockWith[T](consume locked:Locked[T], accEntry:AccountEntry, token:AuthenticationToken):T{
        unlock(locked, authenticateWith(accEntry, token))
    }

    //Todo: entry locks -- using a derive from a key / hashable
}

transactional transaction AccountAuthenticate(accEntry:Account.AccountEntry, token:AuthenticationToken):AuthenticationToken = Account.authenticateWith(accEntry,token)
transactional transaction AccountSubject(accEntry:Account.AccountEntry):Subject = Account.subjectFor(accEntry).subject
transactional transaction AccountCreate(owner:Subject, implicit context consume gen:IdGenerator):(acc:Account.AccountEntry, newGen:IdGenerator) = Account.createAccount(owner)
transactional transaction AccountTransfer(consume accEntry:Account.AccountEntry, newOwner:Subject, auth:AuthenticationToken):Account.AccountEntry = Account.changeOwner(accEntry, newOwner, auth)