import IntU64.U64
import IntU8.U8
import IntI64.I64
import Data._
import Ids._

system(12) module Sys {
   //Note this is temporary to prevent nesting an Entry in a Entry
   // This is no problem, as the top marker indicates special treatment by runtime anyway
   // Meaning the runtime can still persist it
   // in fact the runtime does ignore the persisted capability all together and only looks for tops

   guarded[T] temporary data Entry[persisted T](id:PrivateId,val:T)

   //Information about the current Transaction
   local temporary data Context(bundleHash:Data20, blockNo:U64, sectionNo:U8, txNo:U8)
   //A unique Id generator for the current Transaction
   //Todo: shall we move to ids??
   local temporary affine data IdGenerator(txtId:PrivateId, ctr:U64)

   global function bundleHash(ctx:Context):(txtHash:Data20) = ctx.bundleHash
   global function blockNo(ctx:Context):(blockNo:U64) = ctx.blockNo
   global function sectionNo(ctx:Context):(sectionNo:U8) = ctx.sectionNo
   global function txNo(ctx:Context):(txNo:U8) = ctx.txNo
   global function txtId(gen:IdGenerator):(txtHash:PublicId) = privateToPublic(gen.txtId)

   //Todo: can we make non transactional:
   //      have & use unsave abort??
   global transactional function uniqueID(consume gen:IdGenerator):(id:PrivateId, genOut:IdGenerator) {
     let (txtId, ctr)@gen in (
       derivePrivateId8(txtId, IntU64.toData(ctr)),
       IdGenerator#(txtId, IntU64.add(ctr,1))
     )
   }

   global transactional function subGenerator(consume gen:IdGenerator):(newGen:IdGenerator, genOut:IdGenerator) {
     let (txtId, ctr)@gen in (
       IdGenerator#(derivePrivateId8(txtId, IntU64.toData(ctr)), 0),
       IdGenerator#(txtId, IntU64.add(ctr,1))
     )
   }
}