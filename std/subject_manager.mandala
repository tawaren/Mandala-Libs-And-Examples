import core.Id
import core.sys.Ids.Auth
import core.Derive._
import core.Bool.Bool
import core.Equal
import core.Equal._

//This manages the issuing & authentication of subjects
// Issuers can use this to generate Subjects and AuthenticationTokens of a shared type
// Consumers can use them while abstracting over the issuer (thus working independent of the authentication method)
//This ensures that each issuer has their own subjects and that subjects from different issuers do not collide
module SubjectManager {
    global primitive data AuthenticationRequest(id:Id.Public)
    global primitive data SubjectRequest(id:Id.Public)
    global primitive data Subject(subject:Id.Public)

    //Like identity but creation must be approved by an identity issuer
    global(consume, inspect) local(create) data ValidatedSubject(subject:Subject)
    global(consume, inspect) local(create) temporary data AuthenticationToken(subject:Subject)

    //Just a helper so that callers can evaluate what an expected id is, if they now the issuer and the id
    global function deriveSubjectId(issuer:Id.Public, subject:Id.Public) = derive(issuer, subject)

    //Ensures that to ids only give the same subject if they are from the same issuer
    local function subject(issuer:Id.Public, id:Id.Public) = Subject#(deriveSubjectId(issuer, id))

    //It is given that if you posses an Identity then the issuer has approved its creation (because of Auth)
    // Note: as the Identity can live long it may no longer be active if the issuer has mechanisms to remove ids
    global function validateSubject(req:Auth[SubjectRequest]):(id:ValidatedSubject) {
        let (issuer, request)@req in ValidatedSubject#(subject(issuer, request.id))
    }

    //The resulting AuthenticationToken is valid for the session(transaction bundle) because it is temporary
    // It is given that if you posses an AuthenticationToken then the issuer has approved its creation (because of Auth)
    global function authenticate(req:Auth[AuthenticationRequest]):(token:AuthenticationToken) {
        let (issuer, request)@req in AuthenticationToken#(subject(issuer, request.id))
    }

    //Implement Equality for the types where it makes sense
    global function subjectEq(s1:Subject, s2:Subject) = s1.subject == s2.subject
    instance EqualForSubject for Equal[Subject] {
        implement eq with subjectEq
    }

    global function validatedSubjectEq(s1:ValidatedSubject, s2:ValidatedSubject) = s1.subject == s2.subject
    instance EqualForValidatedSubject for Equal[ValidatedSubject] {
        implement eq with validatedSubjectEq
    }

}

//Class to use issuers generically
// Just for convenience, most of the time issuer is known explicit
class Issuer[I,A] {
    global function subjectFor(id:I):SubjectManager.ValidatedSubject
    global transactional function authenticateWith(authInfo:A):SubjectManager.AuthenticationToken
}

//Subject manager can be seen as an universal issuer bridging the Sanskrit Authentication System into the Mandala one
instance SubjectManagerIsIssuer for Issuer[Auth[SubjectManager.SubjectRequest],Auth[SubjectManager.AuthenticationRequest]]{
    implement subjectFor with SubjectManager.validateSubject
    implement authenticateWith with SubjectManager.authenticate
}